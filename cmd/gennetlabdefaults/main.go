package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

type netlabDeviceCredential struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type netlabDeviceCredentialSet struct {
	Device      string                   `json:"device,omitempty"`
	ImagePrefix string                   `json:"image_prefix,omitempty"`
	Credentials []netlabDeviceCredential `json:"credentials"`
}

type netlabDeviceDefaults struct {
	Source      string                      `json:"source"`
	GeneratedAt string                      `json:"generated_at"`
	Sets        []netlabDeviceCredentialSet `json:"sets"`
	Fallback    []netlabDeviceCredential    `json:"fallback"`
}

func main() {
	var devicesDir string
	var matrixPath string
	var outTaskEngine string
	var outAPI string
	flag.StringVar(&devicesDir, "devices-dir", filepath.FromSlash("../../netlab/netsim/devices"), "Path to netlab/netsim/devices directory")
	flag.StringVar(&matrixPath, "matrix", filepath.FromSlash("./cmd/e2echeck/matrix.devices.yaml"), "Path to e2e matrix file; used to discover supported NETLAB_DEVICE values")
	flag.StringVar(&outTaskEngine, "out-taskengine", filepath.FromSlash("./internal/taskengine/netlab_device_defaults.json"), "Output path for taskengine embedded netlab defaults JSON")
	flag.StringVar(&outAPI, "out-api", filepath.FromSlash("./skyforge/netlab_device_defaults.json"), "Output path for api embedded netlab defaults JSON")
	flag.Parse()

	devices := map[string]bool{}
	for _, d := range devicesFromMatrix(matrixPath) {
		devices[d] = true
	}
	for _, d := range devicesFromCatalog(outAPI) {
		devices[d] = true
	}
	for _, d := range devicesFromCatalog(outTaskEngine) {
		devices[d] = true
	}
	// Ensure a few common normalization keys exist in the catalog (these are used by Skyforge
	// when netlab status output omits a specific device label).
	for _, d := range []string{"ios", "junos", "linux"} {
		devices[d] = true
	}

	deviceList := make([]string, 0, len(devices))
	for d := range devices {
		d = strings.ToLower(strings.TrimSpace(d))
		if d == "" {
			continue
		}
		deviceList = append(deviceList, d)
	}
	sort.Strings(deviceList)

	sets := make([]netlabDeviceCredentialSet, 0, len(deviceList))
	for _, device := range deviceList {
		cred, imagePrefix, err := resolveDeviceCredential(devicesDir, device)
		if err != nil {
			fail("resolve %q failed: %v", device, err)
		}
		if strings.TrimSpace(cred.Username) == "" || strings.TrimSpace(cred.Password) == "" {
			fail("resolve %q returned empty credential", device)
		}
		sets = append(sets, netlabDeviceCredentialSet{
			Device:      device,
			ImagePrefix: imagePrefix,
			Credentials: []netlabDeviceCredential{cred},
		})
	}

	sort.SliceStable(sets, func(i, j int) bool {
		if sets[i].Device != sets[j].Device {
			return sets[i].Device < sets[j].Device
		}
		return sets[i].ImagePrefix < sets[j].ImagePrefix
	})

	out := netlabDeviceDefaults{
		Source:      "netlab/netsim/devices/*.yml (generated by skyforge-private/server/cmd/gennetlabdefaults)",
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
		Sets:        sets,
		Fallback:    []netlabDeviceCredential{},
	}
	writeJSON(outTaskEngine, out)
	writeJSON(outAPI, out)
}

func fail(format string, args ...any) {
	_, _ = fmt.Fprintf(os.Stderr, format+"\n", args...)
	os.Exit(1)
}

func writeJSON(path string, value any) {
	data, err := json.MarshalIndent(value, "", "  ")
	if err != nil {
		fail("marshal %s failed: %v", path, err)
	}
	data = append(data, '\n')
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		fail("mkdir %s failed: %v", filepath.Dir(path), err)
	}
	if err := os.WriteFile(path, data, 0o644); err != nil {
		fail("write %s failed: %v", path, err)
	}
}

func devicesFromCatalog(path string) []string {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil
	}
	var catalog struct {
		Sets []struct {
			Device string `json:"device"`
		} `json:"sets"`
	}
	if err := json.Unmarshal(data, &catalog); err != nil {
		return nil
	}
	out := []string{}
	seen := map[string]bool{}
	for _, set := range catalog.Sets {
		d := strings.ToLower(strings.TrimSpace(set.Device))
		if d == "" || seen[d] {
			continue
		}
		seen[d] = true
		out = append(out, d)
	}
	sort.Strings(out)
	return out
}

func devicesFromMatrix(path string) []string {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil
	}
	var root map[string]any
	if err := yaml.Unmarshal(data, &root); err != nil {
		return nil
	}
	testsAny := asSlice(root["tests"])
	out := []string{}
	seen := map[string]bool{}
	for _, testAny := range testsAny {
		testMap := asMap(testAny)
		if len(testMap) == 0 {
			continue
		}
		kind := strings.TrimSpace(fmt.Sprintf("%v", testMap["kind"]))
		var env map[string]any
		switch kind {
		case "netlab_validate":
			env = asMap(asMap(testMap["netlab_validate"])["environment"])
		case "netlab_deploy":
			env = asMap(asMap(testMap["netlab_deploy"])["environment"])
		default:
			continue
		}
		if len(env) == 0 {
			continue
		}
		dev := strings.ToLower(strings.TrimSpace(fmt.Sprintf("%v", env["NETLAB_DEVICE"])))
		if dev == "" || seen[dev] {
			continue
		}
		seen[dev] = true
		out = append(out, dev)
	}
	sort.Strings(out)
	return out
}

func resolveDeviceCredential(devicesDir, device string) (netlabDeviceCredential, string, error) {
	device = strings.ToLower(strings.TrimSpace(device))
	if device == "" {
		return netlabDeviceCredential{}, "", fmt.Errorf("empty device")
	}

	visited := map[string]bool{}
	cur := device
	imagePrefix := ""

	for cur != "" {
		if visited[cur] {
			return netlabDeviceCredential{}, "", fmt.Errorf("parent loop detected at %q", cur)
		}
		visited[cur] = true

		node, err := readYAMLFile(filepath.Join(devicesDir, cur+".yml"))
		if err != nil {
			return netlabDeviceCredential{}, "", fmt.Errorf("read %q: %w", cur, err)
		}

		// Prefer image prefix from the most-specific device file.
		if imagePrefix == "" {
			clab := asMap(node["clab"])
			imagePrefix = normalizeImagePrefix(strings.TrimSpace(fmt.Sprintf("%v", clab["image"])))
		}

		// Prefer containerlab (clab) group_vars for default credentials.
		clab := asMap(node["clab"])
		if cred, ok := credentialFromGroupVars(asMap(clab["group_vars"])); ok {
			return cred, imagePrefix, nil
		}
		if cred, ok := credentialFromGroupVars(asMap(node["group_vars"])); ok {
			return cred, imagePrefix, nil
		}

		cur = normalizeParent(node["parent"])
	}

	return netlabDeviceCredential{}, imagePrefix, fmt.Errorf("no credential found in device file or parent chain")
}

func credentialFromGroupVars(vars map[string]any) (netlabDeviceCredential, bool) {
	if len(vars) == 0 {
		return netlabDeviceCredential{}, false
	}
	user := strings.TrimSpace(fmt.Sprintf("%v", vars["ansible_user"]))
	pass := ""
	if v, ok := vars["ansible_ssh_pass"]; ok {
		pass = strings.TrimSpace(fmt.Sprintf("%v", v))
	}
	if pass == "" {
		if v, ok := vars["ansible_password"]; ok {
			pass = strings.TrimSpace(fmt.Sprintf("%v", v))
		}
	}
	if user == "" || pass == "" {
		return netlabDeviceCredential{}, false
	}
	return netlabDeviceCredential{Username: user, Password: pass}, true
}

func normalizeParent(parentAny any) string {
	switch v := parentAny.(type) {
	case string:
		return strings.ToLower(strings.TrimSpace(v))
	case []any:
		if len(v) == 0 {
			return ""
		}
		if s, ok := v[0].(string); ok {
			return strings.ToLower(strings.TrimSpace(s))
		}
		return strings.ToLower(strings.TrimSpace(fmt.Sprintf("%v", v[0])))
	default:
		return strings.ToLower(strings.TrimSpace(fmt.Sprintf("%v", parentAny)))
	}
}

func normalizeImagePrefix(image string) string {
	image = strings.TrimSpace(image)
	if image == "" || image == "none" {
		return ""
	}
	// Strip digest if present.
	if before, _, ok := strings.Cut(image, "@"); ok {
		image = before
	}
	// Strip tag by removing the last ':' occurring after the last '/'.
	lastSlash := strings.LastIndex(image, "/")
	lastColon := strings.LastIndex(image, ":")
	if lastColon > lastSlash {
		image = image[:lastColon]
	}
	return strings.TrimSpace(image)
}

func readYAMLFile(path string) (map[string]any, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var node map[string]any
	if err := yaml.Unmarshal(data, &node); err != nil {
		return nil, err
	}
	return node, nil
}

func asMap(value any) map[string]any {
	switch typed := value.(type) {
	case map[string]any:
		return typed
	case map[any]any:
		out := map[string]any{}
		for k, v := range typed {
			out[fmt.Sprintf("%v", k)] = v
		}
		return out
	default:
		return nil
	}
}

func asSlice(value any) []any {
	if value == nil {
		return nil
	}
	if out, ok := value.([]any); ok {
		return out
	}
	return nil
}
