/**
 * @intent Policy risk/recertification: PERMIT rules with any service match (firewalls).
 * @description
 *  Flags PERMIT rules whose modeled service match is effectively "any protocol" AND "any destination port".
 *  (Order-agnostic, modeled view; not a vendor config parser.)
 */

@query
aclPermitAnyService =
  foreach device in network.devices
  where device.platform.deviceType == DeviceType.FIREWALL

  foreach aclEntry in device.aclEntries
  let h = aclEntry.headerMatches
  where aclEntry.action == AclAction.PERMIT
  where !aclEntry.implicitRule
  where !aclEntry.defaultRule

  let isAnyProto =
    length(h.ipProtocol) == 0 ||
    any(foreach r in h.ipProtocol select r.start <= 0 && 255 <= r.end)
  let isAnyPort =
    length(h.tpDst) == 0 ||
    any(foreach r in h.tpDst select r.start <= 0 && 65535 <= r.end)
  let isAnyService = isAnyProto && isAnyPort

  where isAnyService
  select {
    violation: true,
    device: device.name,
    rule: aclEntry.name,
    action: aclEntry.action,
    reason: "ANY_SERVICE",
    ipv4Src: h.ipv4Src,
    ipv4Dst: h.ipv4Dst,
    ipProto: h.ipProtocol,
    tpDst: h.tpDst,
    lastUsed: aclEntry.lifecycleData?.lastUsed,
    hitCount: aclEntry.lifecycleData?.truncatedHitCount,
    createdAt: aclEntry.lifecycleData?.createdAt,
    lastModified: aclEntry.lifecycleData?.lastModified,
    ingress: aclEntry.metadataMatches.ingressInterfaces,
    egress: aclEntry.metadataMatches.egressInterfaces,
    os: device.platform.os,
    vendor: device.platform.vendor,
    tags: device.tagNames
  };

