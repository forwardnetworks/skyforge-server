/**
 * @intent Policy analytics: find partially shadowed ACL rules (same action) based on modeled match regions.
 * @description
 *  A rule J is considered partially shadowed if there exists an earlier rule I with the same action such that
 *  match(J) overlaps match(I) but is not a subset of match(I).
 *
 *  Notes:
 *  - Conservative: focuses on ipv4Src/ipv4Dst/ipProtocol/tpDst only.
 *  - Empty match fields are treated as "any".
 */

subnetsToSet(subnets) = ipAddressSet(subnets);

subnetsSubset(a, b) =
  if length(a) == 0 then length(b) == 0
  else if length(b) == 0 then true
  else subnetsToSet(a) in subnetsToSet(b);

subnetsOverlap(a, b) =
  length(a) == 0 || length(b) == 0 ||
  !isEmpty(intersect(subnetsToSet(a), subnetsToSet(b)));

rangesSubset(a, b) =
  if length(a) == 0 then length(b) == 0
  else if length(b) == 0 then true
  else all(
    foreach ra in a
    select any(
      foreach rb in b
      select rb.start <= ra.start && ra.end <= rb.end
    )
  );

rangesOverlap(a, b) =
  length(a) == 0 || length(b) == 0 ||
  any(
    foreach ra in a
    foreach rb in b
    select ra.start <= rb.end && rb.start <= ra.end
  );

headerSubset(hA, hB) =
  subnetsSubset(hA.ipv4Src, hB.ipv4Src) &&
  subnetsSubset(hA.ipv4Dst, hB.ipv4Dst) &&
  rangesSubset(hA.ipProtocol, hB.ipProtocol) &&
  rangesSubset(hA.tpDst, hB.tpDst);

headerOverlap(hA, hB) =
  subnetsOverlap(hA.ipv4Src, hB.ipv4Src) &&
  subnetsOverlap(hA.ipv4Dst, hB.ipv4Dst) &&
  rangesOverlap(hA.ipProtocol, hB.ipProtocol) &&
  rangesOverlap(hA.tpDst, hB.tpDst);

@query
aclPartialShadowedRules(firewallsOnly : Bool, includeImplicitDefault : Bool) =
  foreach device in network.devices
  where !firewallsOnly || device.platform.deviceType == DeviceType.FIREWALL
  let rules = device.aclEntries
  foreach j in fromTo(0, length(rules) - 1)
  let rj = rules[j]
  where includeImplicitDefault || (!rj.implicitRule && !rj.defaultRule)

  foreach i in fromTo(0, j - 1)
  let ri = rules[i]
  where includeImplicitDefault || (!ri.implicitRule && !ri.defaultRule)
  where ri.action == rj.action

  let hj = rj.headerMatches
  let hi = ri.headerMatches
  where headerOverlap(hj, hi)
  where !headerSubset(hj, hi)

  select {
    violation: true,
    device: device.name,
    partiallyShadowedRuleIndex: j,
    partiallyShadowedRule: rj.name,
    partiallyShadowedAction: rj.action,
    partiallyShadowedEvidence: sourceConfigText(rj.name),
    earlierRuleIndex: i,
    earlierRule: ri.name,
    earlierEvidence: sourceConfigText(ri.name),
    overApproximated: hj.overApproximated || hi.overApproximated
  };

