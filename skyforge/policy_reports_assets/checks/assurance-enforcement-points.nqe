/**
 * @intent Assurance helper: discover enforcement points
 * @description
 *  Returns a list of devices that should be treated as "enforcement points" for
 *  Paths Assurance and other demo workflows.
 *
 *  Notes:
 *  - This is intentionally conservative by default: if no explicit deviceTypes
 *    are provided, we match only explicit firewall-ish device types.
 *  - nameParts/tagParts are substring (case-insensitive) matches in NQE, mirroring
 *    the demo UI semantics.
 *  - The Go layer treats the NQE-derived device set as authoritative when present,
 *    and uses local substring matching only as a fallback if the helper query fails.
 */

asLower(s) =
  toLowerCase(if isPresent(s) then s else "");

nonEmptyLower(ss) =
  (
    foreach s in ss
    let v = asLower(s)
    where v != ""
    select v
  );

isDefaultEnforcementType(dt) =
  asLower(toString(dt)) in ["firewall",
                            "aws_network_firewall",
                            "azure_firewall",
                            "azure_virtual_appliance"];

typeMatches(dt, wantedLower) =
  (length(wantedLower) == 0 && isDefaultEnforcementType(dt)) ||
  (length(wantedLower) > 0 && asLower(toString(dt)) in wantedLower);

matchesAnyPart(hayLower, partsLower) =
  length(partsLower) > 0 &&
  any(foreach p in partsLower
      // NQE `matches` behaves like a substring/regex predicate; we rely on
      // the demo input being simple tokens (no escaping).
      select p != "" && matches(hayLower, p));

tagMatches(tags, partsLower) =
  any(foreach t in tags
      let tl = asLower(t)
      select tl != "" && matchesAnyPart(tl, partsLower));

@query
assuranceEnforcementPoints(
  enforcementDeviceTypes : List<String>,
  enforcementDeviceNameParts : List<String>,
  enforcementTagParts : List<String>,
  includeGroups : Bool
) =
  foreach device in network.devices
  let devTypesLower = nonEmptyLower(enforcementDeviceTypes)
  let namePartsLower = nonEmptyLower(enforcementDeviceNameParts)
  let tagPartsLower = nonEmptyLower(enforcementTagParts)
  let dt = device.platform.deviceType
  let tags = device.tagNames
  where typeMatches(dt, devTypesLower) ||
        matchesAnyPart(asLower(device.name), namePartsLower) ||
        (length(tagPartsLower) > 0 && (tagMatches(tags, tagPartsLower) ||
                                      (includeGroups && tagMatches(device.groupNames, tagPartsLower))))
  select {
    deviceName: device.name,
    deviceType: toString(dt),
    tagNames: device.tagNames,
    groupNames: device.groupNames
  };
