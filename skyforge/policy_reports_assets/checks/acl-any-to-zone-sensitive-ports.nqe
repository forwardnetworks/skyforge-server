/**
 * @intent Exposure/segmentation: PERMIT from any source to a zone on sensitive ports.
 * @description
 *  Uses modeled ACL entries (device.aclEntries).
 *  Destination zone is defined by subnet lists (strings parsed via ipSubnet()).
 */

subnetsFromStrings(ss) =
  foreach s in ss select ipSubnet(s);

dstSetFromStrings(ss) =
  ipAddressSet(subnetsFromStrings(ss));

dstOverlapsZone(ruleSubnets, zoneSet) =
  length(ruleSubnets) == 0 ||
  !isEmpty(intersect(ipAddressSet(ruleSubnets), zoneSet));

containsIntRange(ranges, v) =
  length(ranges) == 0 ||
  any(foreach r in ranges
      select r.start <= v && v <= r.end);

protoAllowsTcpOrUdp(protoRanges) =
  length(protoRanges) == 0 ||
  containsIntRange(protoRanges, 6) ||
  containsIntRange(protoRanges, 17);

isAnySrc(subnets) =
  length(subnets) == 0 || ipSubnet("0.0.0.0/0") in subnets;

@query
aclAnyToZoneSensitivePorts(
  dstSubnets : List<String>,
  sensitivePorts : List<Integer>,
  firewallsOnly : Bool,
  includeImplicitDefault : Bool
) =
  let dstSet = dstSetFromStrings(dstSubnets)
  foreach device in network.devices
  where !firewallsOnly || device.platform.deviceType == DeviceType.FIREWALL
  foreach aclEntry in device.aclEntries
  let h = aclEntry.headerMatches
  where aclEntry.action == AclAction.PERMIT
  where includeImplicitDefault || (!aclEntry.implicitRule && !aclEntry.defaultRule)
  where isAnySrc(h.ipv4Src)
  where dstOverlapsZone(h.ipv4Dst, dstSet)
  where protoAllowsTcpOrUdp(h.ipProtocol)
  where any(foreach p in sensitivePorts
            select containsIntRange(h.tpDst, p))
  select {
    violation: true,
    findingId: device.name + ":" + aclEntry.name + ":any-to-zone-sensitive",
    riskScore: 90,
    assetKey: device.name,
    device: device.name,
    rule: aclEntry.name,
    action: aclEntry.action,
    evidence: sourceConfigText(aclEntry.name),
    dstSubnets: dstSubnets,
    sensitivePorts: sensitivePorts,
    ipv4Src: h.ipv4Src,
    ipv4Dst: h.ipv4Dst,
    ipProto: h.ipProtocol,
    tpDst: h.tpDst,
    ingress: aclEntry.metadataMatches.ingressInterfaces,
    egress: aclEntry.metadataMatches.egressInterfaces,
    implicit: aclEntry.implicitRule,
    defaultRule: aclEntry.defaultRule,
    overApproximated: h.overApproximated,
    lastUsed: aclEntry.lifecycleData?.lastUsed,
    hitCount: aclEntry.lifecycleData?.truncatedHitCount
  };

