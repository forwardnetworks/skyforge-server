/**
 * @intent Policy risk: PERMIT from any source to RFC1918 on sensitive ports.
 * @description
 *  Uses modelled ACL entries (device.aclEntries) rather than config text.
 *  Flags permit rules where ipv4Src includes 0.0.0.0/0 and ipv4Dst overlaps RFC1918,
 *  and the destination port range includes any sensitive port (or port range is "any").
 */

privateSubnets =
  [ipSubnet("10.0.0.0/8"),
   ipSubnet("172.16.0.0/12"),
   ipSubnet("192.168.0.0/16")
  ];
privateIpAddressSet = ipAddressSet(privateSubnets);

includesPort(ranges, port) =
  length(ranges) == 0 ||
  any(foreach r in ranges
      select r.start <= port && port <= r.end);

@query
aclAnyToRfc1918SensitivePorts(sensitivePorts : List<Integer>) =
  foreach device in network.devices
  foreach aclEntry in device.aclEntries
  let h = aclEntry.headerMatches
  where aclEntry.action == AclAction.PERMIT

  let isAnySrc = length(h.ipv4Src) == 0 || ipSubnet("0.0.0.0/0") in h.ipv4Src
  let dstOverlapsPrivate =
    length(h.ipv4Dst) == 0 ||
    !isEmpty(intersect(ipAddressSet(h.ipv4Dst), privateIpAddressSet))
  let isTcpOrUdp =
    length(h.ipProtocol) == 0 ||
    any(foreach r in h.ipProtocol
        select (r.start <= 6 && 6 <= r.end) || (r.start <= 17 && 17 <= r.end))
  let hitsSensitivePort =
    any(foreach p in sensitivePorts
        select includesPort(h.tpDst, p))

  where isAnySrc
  where dstOverlapsPrivate
  where isTcpOrUdp
  where hitsSensitivePort
  select {
    violation: true,
    device: device.name,
    rule: aclEntry.name,
    action: aclEntry.action,
    evidence: sourceConfigText(aclEntry.name),
    ipv4Src: h.ipv4Src,
    ipv4Dst: h.ipv4Dst,
    ipProto: h.ipProtocol,
    tpDst: h.tpDst,
    sensitivePorts: sensitivePorts,
    ingress: aclEntry.metadataMatches.ingressInterfaces,
    egress: aclEntry.metadataMatches.egressInterfaces,
    implicit: aclEntry.implicitRule,
    defaultRule: aclEntry.defaultRule,
    lastUsed: aclEntry.lifecycleData?.lastUsed,
    hitCount: aclEntry.lifecycleData?.truncatedHitCount
  };
