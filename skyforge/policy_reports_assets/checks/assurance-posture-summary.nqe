/**
 * @intent Assurance posture: summary findings (single NQE)
 * @description
 *  Emits a single list of high-signal posture findings used by the assurance
 *  summary tile. This intentionally mirrors the "assurance-demo" pack, but
 *  runs as ONE NQE query to minimize backend orchestration.
 *
 *  Notes:
 *  - NQE does not currently support imports, so this file includes small
 *    copies of the relevant checks.
 *  - Each row includes its own severity/category/checkId so Skyforge can
 *    compute reasonable risk ordering.
 */

// ---- Shared helpers (copied / simplified) ----

privateSubnets =
  [ipSubnet("10.0.0.0/8"),
   ipSubnet("172.16.0.0/12"),
   ipSubnet("192.168.0.0/16")
  ];
privateIpAddressSet = ipAddressSet(privateSubnets);

includesPort(ranges, port) =
  length(ranges) == 0 ||
  any(foreach r in ranges
      select r.start <= port && port <= r.end);

// ---- Findings ----

aclAnyAny =
  foreach device in network.devices
  foreach aclEntry in device.aclEntries
  let h = aclEntry.headerMatches
  where aclEntry.action == AclAction.PERMIT
  where ipSubnet("0.0.0.0/0") in h.ipv4Src
  where ipSubnet("0.0.0.0/0") in h.ipv4Dst
  select {
    violation: true,
    checkId: "acl-any-any-permit.nqe",
    checkTitle: "PERMIT any-to-any (modeled ACL)",
    category: "policy-risk",
    severity: "high",
    findingId: device.name + ":" + aclEntry.name + ":any-any",
    assetKey: device.name,

    device: device.name,
    rule: aclEntry.name,
    action: aclEntry.action,
    evidence: sourceConfigText(aclEntry.name),
    ipv4Src: h.ipv4Src,
    ipv4Dst: h.ipv4Dst,
    ipProto: h.ipProtocol,
    tpDst: h.tpDst
  };

aclAnyService =
  foreach device in network.devices
  where device.platform.deviceType == DeviceType.FIREWALL
  foreach aclEntry in device.aclEntries
  let h = aclEntry.headerMatches
  where aclEntry.action == AclAction.PERMIT
  where !aclEntry.implicitRule
  where !aclEntry.defaultRule

  let isAnyProto =
    length(h.ipProtocol) == 0 ||
    any(foreach r in h.ipProtocol select r.start <= 0 && 255 <= r.end)
  let isAnyPort =
    length(h.tpDst) == 0 ||
    any(foreach r in h.tpDst select r.start <= 0 && 65535 <= r.end)
  where isAnyProto && isAnyPort
  select {
    violation: true,
    checkId: "acl-permit-any-service.nqe",
    checkTitle: "PERMIT rules with any service match (any protocol and any port)",
    category: "policy-risk",
    severity: "high",
    findingId: device.name + ":" + aclEntry.name + ":any-service",
    assetKey: device.name,

    device: device.name,
    rule: aclEntry.name,
    action: aclEntry.action,
    reason: "ANY_SERVICE",
    evidence: sourceConfigText(aclEntry.name),
    ipv4Src: h.ipv4Src,
    ipv4Dst: h.ipv4Dst,
    ipProto: h.ipProtocol,
    tpDst: h.tpDst,
    lastUsed: aclEntry.lifecycleData?.lastUsed,
    hitCount: aclEntry.lifecycleData?.truncatedHitCount
  };

aclAnyToRfc1918(sensitivePorts) =
  foreach device in network.devices
  foreach aclEntry in device.aclEntries
  let h = aclEntry.headerMatches
  where aclEntry.action == AclAction.PERMIT

  let isAnySrc = length(h.ipv4Src) == 0 || ipSubnet("0.0.0.0/0") in h.ipv4Src
  let dstOverlapsPrivate =
    length(h.ipv4Dst) == 0 ||
    !isEmpty(intersect(ipAddressSet(h.ipv4Dst), privateIpAddressSet))
  let isTcpOrUdp =
    length(h.ipProtocol) == 0 ||
    any(foreach r in h.ipProtocol
        select (r.start <= 6 && 6 <= r.end) || (r.start <= 17 && 17 <= r.end))
  let hitsSensitivePort =
    any(foreach p in sensitivePorts
        select includesPort(h.tpDst, p))

  where isAnySrc
  where dstOverlapsPrivate
  where isTcpOrUdp
  where hitsSensitivePort
  select {
    violation: true,
    checkId: "acl-any-to-rfc1918-sensitive-ports.nqe",
    checkTitle: "PERMIT any-to-RFC1918 on sensitive ports (modeled ACL)",
    category: "policy-risk",
    severity: "high",
    findingId: device.name + ":" + aclEntry.name + ":any-to-rfc1918-sensitive",
    assetKey: device.name,

    device: device.name,
    rule: aclEntry.name,
    action: aclEntry.action,
    evidence: sourceConfigText(aclEntry.name),
    ipv4Src: h.ipv4Src,
    ipv4Dst: h.ipv4Dst,
    ipProto: h.ipProtocol,
    tpDst: h.tpDst,
    sensitivePorts: sensitivePorts
  };

defaultRouteNoUrpf =
  foreach device in network.devices
  where isPresent(device.files.config)
  where device.platform.os in [OS.IOS, OS.IOS_XE, OS.NXOS, OS.ARISTA_EOS, OS.JUNOS]

  let iosDefault = `ip route 0.0.0.0 0.0.0.0 {rest:string}`
  let junosDefault = `0.0.0.0/0 {rest:string}`
  let defaultMatches = patternMatches(device.files.config, iosDefault) + patternMatches(device.files.config, junosDefault)
  let hasDefaultRoute = length(defaultMatches) > 0

  let urpf1 = `ip verify unicast source reachable-via {rest:string}`
  let urpf2 = `rpf-check {rest:string}`
  let urpfMatches = patternMatches(device.files.config, urpf1) + patternMatches(device.files.config, urpf2)
  let hasUrpf = length(urpfMatches) > 0

  where hasDefaultRoute
  where !hasUrpf
  select {
    violation: true,
    checkId: "default-route-urpf-heuristic.nqe",
    checkTitle: "Default route without obvious uRPF (config heuristic)",
    category: "routing-hardening",
    severity: "medium",
    findingId: device.name + ":default-route-no-urpf",
    assetKey: device.name,

    device: device.name,
    os: device.platform.os,
    defaultRouteLines: foreach m in defaultMatches select m.line.text,
    urpfLines: foreach m in urpfMatches select m.line.text
  };

ospfPassiveDefaultMissing =
  foreach device in network.devices
  where isPresent(device.files.config)
  where device.platform.os in [OS.IOS, OS.IOS_XE, OS.NXOS, OS.ARISTA_EOS]
  let ospfHeader = `router ospf {processId:string}`
  foreach ospf in patternMatches(device.files.config, ospfHeader)
  let line = ospf.line
  let children = line.children
  let hasPassiveDefault = any(foreach c in children select matches(c.text, "passive-interface default"))
  where !hasPassiveDefault
  select {
    violation: true,
    checkId: "ospf-passive-default.nqe",
    checkTitle: "OSPF passive-interface default missing (config heuristic)",
    category: "routing-hardening",
    severity: "low",
    findingId: device.name + ":ospf:" + ospf.data.processId + ":passive-default-missing",
    assetKey: device.name,

    device: device.name,
    os: device.platform.os,
    ospfProcess: ospf.data.processId
  };

@query
assurancePostureSummary(sensitivePorts : List<Integer>) =
  aclAnyAny +
  aclAnyService +
  aclAnyToRfc1918(sensitivePorts) +
  defaultRouteNoUrpf +
  ospfPassiveDefaultMissing;
